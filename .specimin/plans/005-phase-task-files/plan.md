**Technical Context**

**Existing**: Bash-based plugin system with markdown command definitions | LLM-driven workflow automation | Git-based feature branch management | Markdown-structured artifacts (spec.md, plan.md, implementation.md)

**Detected**: Claude Code environment with Write, Read, Edit, Bash tools | `.specimin/` directory structure with `plans/{branch}/` pattern | Slash command system in `.claude-plugin/commands/` | Sequential task format with T001-style IDs and phase organization

**Unknowns Resolved**:
- LLM-based semantic parsing for implementation.md extraction
- Minimal JSON manifest schema (id, description, phase, status only)
- Preserve global task IDs from implementation.md in phase files
- Numeric phase file naming (phase_1.md, phase_2.md)
- Direct JSON editing via Edit tool for status updates

---

**Decision Exploration**

### Decision 1: Parsing Strategy for implementation.md

**Options Explored**:
- **LLM-based semantic parsing**: Flexible, context-aware extraction of phases and tasks using natural language understanding. Handles format variations gracefully but consumes more tokens.
- **Regex-based pattern matching**: Fast, deterministic extraction using pattern matching. Efficient but brittle to format changes.
- **Hybrid approach**: Combines regex speed with LLM validation for error detection.

**Selected**: LLM-based semantic parsing

**Rationale**: Given that the `/specimin:cmd.implement` command is LLM-driven and generates implementation.md, maintaining consistency by using LLM parsing for extraction aligns with the plugin's philosophy. The implementation.md format is generated by an LLM agent, so using LLM understanding to parse it creates a natural symmetry. While more token-intensive, this approach provides robustness against minor formatting variations and allows the agent to intelligently group related tasks (especially TDD cycles: test→verify→implement→verify).

### Decision 2: JSON Manifest Schema Depth

**Options Explored**:
- **Strict minimal (id, description, phase, status)**: Simplest structure, fastest to parse, minimal storage.
- **Add task index and file paths**: Enables quick lookup and better debugging context.
- **Add timestamps and execution metadata**: Full analytics capability with time tracking.

**Selected**: Strict minimal schema

**Rationale**: Aligns with spec requirement for "minimal task metadata" and keeps the system simple for v1. The manifest's primary purpose is programmatic task traversal and status tracking, not analytics. Additional metadata can be added later if needed without breaking the core workflow. Minimal schema reduces complexity in status update operations and keeps JSON parsing lightweight.

### Decision 3: Task ID Scheme

**Options Explored**:
- **Preserve global IDs (T001, T002...)**: Direct traceability to implementation.md source.
- **Renumber per-phase (P1T001, P2T001...)**: Self-contained phase files with local context.
- **Dual IDs**: Maintain both global and local IDs for different purposes.

**Selected**: Preserve global IDs from implementation.md

**Rationale**: Maintaining the original T001-style sequential IDs provides clear traceability between implementation.md and the generated phase files. This simplifies debugging (users can reference the same task ID across documents) and eliminates the need for ID mapping logic. While phase_2.md might start with T015, this is acceptable because the phase header provides context, and the JSON manifest can be queried to determine task-to-phase relationships.

### Decision 4: Phase File Naming

**Options Explored**:
- **Numeric only (phase_1.md)**: Simple, predictable, no special character handling.
- **Semantic names (foundation_setup.md)**: Self-documenting, descriptive.
- **Combined (1_foundation_setup.md)**: Sortable with readable context.

**Selected**: Numeric only (phase_1.md, phase_2.md)

**Rationale**: Prioritizes simplicity and reliability. Numeric naming eliminates edge cases with special characters, long names, or duplicate phase titles. File sorting is predictable, and the phase semantic name is preserved as a header within each markdown file (e.g., `# Phase 1: Foundation Setup`), so context is not lost. This approach requires no string sanitization logic and works universally across file systems.

### Decision 5: Status Update Mechanism

**Options Explored**:
- **Direct JSON edit via Edit tool**: Simple, single tool call, uses existing infrastructure.
- **Python helper script**: Safe, validated updates with JSON schema enforcement.
- **Read-modify-write pattern**: Full LLM context with validation before writing.

**Selected**: Direct JSON edit via Edit tool

**Rationale**: Leverages the existing Edit tool that coding agents already use extensively. While JSON editing can be brittle, the minimal manifest schema (flat array of task objects) is simple enough to edit reliably. The Edit tool's exact string matching prevents accidental corruption of other tasks. This approach avoids introducing new dependencies (Python scripts) and keeps the workflow within the native Claude Code tool ecosystem, maintaining consistency with how agents already interact with files.

---

**Solution Architecture**

The solution extends the `/specimin:cmd.implement` command to perform phase file generation and manifest creation immediately after generating implementation.md. When the command completes, it will invoke an LLM-driven extraction workflow that semantically parses implementation.md to identify phase boundaries and task groupings.

The extraction process reads implementation.md and uses natural language understanding to identify sections marked by `## Phase N:` headers. For each phase, it collects all task items (those following the checkbox format `- [ ] TXXX`) and their associated metadata (descriptions, dependencies, parallel markers). The agent constructs phase-specific markdown files containing the phase header, dependency information, and all tasks belonging to that phase, preserving the original task IDs and formatting.

Simultaneously, the agent builds a JSON manifest as an array of task objects. Each object contains four fields: a unique task ID (e.g., "T001"), a task description extracted from the markdown, the phase number (integer), and a status field initialized to "pending". The manifest is written to `manifest.json` in the tasks directory, providing a machine-readable index for programmatic task traversal.

Coding agents consume these artifacts by first querying manifest.json to find the next pending task, then reading the corresponding phase file for full context. Task execution follows a simple pattern: mark task as "in_progress" in the manifest (via Edit tool), execute the work, then update status to "completed". The phase files remain read-only reference documents, while manifest.json serves as the mutable state tracker.

---

**Technology Decisions**

- **File format**: Markdown for phase files (human-readable, consistent with existing artifacts), JSON for manifest (machine-parsable)
- **Parsing approach**: LLM semantic parsing using Claude's natural language understanding to extract structured data from implementation.md
- **Storage location**: `.specimin/plans/{branch}/tasks/` subdirectory (alongside spec.md, plan.md, implementation.md)
- **Status values**: Three-state enum: "pending", "in_progress", "completed"
- **File naming**: Zero-padded numeric convention (phase_1.md, phase_2.md) for reliable sorting
- **Update mechanism**: Edit tool with exact string matching for atomic manifest updates

---

**Component Modifications**

1. **`/specimin:cmd.implement` command** ([.claude-plugin/commands/cmd.implement.md](.claude-plugin/commands/cmd.implement.md)): Add post-generation workflow stage after implementation.md is saved. Insert new Stage 7 that triggers phase file generation and manifest creation.

---

**New Components**

1. **Phase file generator prompt section** (embedded in cmd.implement.md): LLM instructions for parsing implementation.md, extracting phases and tasks, generating phase_N.md files with proper markdown formatting.

2. **Manifest generator prompt section** (embedded in cmd.implement.md): LLM instructions for constructing the JSON manifest array from parsed tasks, ensuring valid JSON structure with proper escaping.

3. **Phase markdown files** (`.specimin/plans/{branch}/tasks/phase_N.md`): Generated output files containing phase header, dependencies, and all tasks for that phase in checkbox format.

4. **Task manifest file** (`.specimin/plans/{branch}/tasks/manifest.json`): Generated JSON array serving as authoritative source for task status tracking.

---

**Task Sequence**

**Phase 1: Foundation - Task Directory Setup**

1. Create tasks directory creation logic in cmd.implement.md after implementation.md save step
   - **What**: Add Bash command to create `.specimin/plans/{branch}/tasks/` directory if it doesn't exist
   - **Why**: Ensures target directory exists before writing phase files

**Dependencies**: None

**Phase 2: Implementation Parsing**

2. Add LLM prompt section for semantic parsing of implementation.md
   - **What**: Insert prompt instructions that guide the LLM to read implementation.md and identify phase boundaries using headers like `## Phase N:`
   - **Why**: Provides the agent with structured instructions for extracting phase-structured data

3. Add task extraction logic to parsing prompt
   - **What**: Extend parsing prompt to extract task lines (checkbox format `- [ ] TXXX Description`) and associated metadata (task ID, description, phase number)
   - **Why**: Captures the core data needed to populate both phase files and manifest

**Dependencies**: Phase 1

**Phase 3: Phase File Generation**

4. Add phase file writing instructions to cmd.implement.md
   - **What**: Insert prompt section that instructs agent to create phase_N.md files using Write tool, with content including phase header, dependencies section, and filtered task list
   - **Why**: Generates the human-readable phase files that coding agents will reference during execution

5. Add phase metadata preservation logic
   - **What**: Ensure prompt instructs agent to copy phase name, dependency information, and parallel opportunity counts from implementation.md into each phase file header
   - **Why**: Maintains context and metadata within phase files so they're self-contained

**Dependencies**: Phase 2

**Phase 4: Manifest Generation**

6. Add manifest JSON construction instructions to cmd.implement.md
   - **What**: Insert prompt section that instructs agent to build a JSON array of task objects with fields: id, description, phase, status (initialized to "pending")
   - **Why**: Creates the machine-readable manifest that serves as the source of truth for task status

7. Add JSON escaping and validation instructions
   - **What**: Include prompt guidance for proper JSON string escaping (quotes, newlines, special characters) and validation before writing
   - **Why**: Prevents JSON corruption from task descriptions containing special characters

8. Add manifest file write operation to prompt
   - **What**: Instruct agent to write the constructed JSON to `.specimin/plans/{branch}/tasks/manifest.json` using Write tool
   - **Why**: Persists the manifest for programmatic access by coding agents

**Dependencies**: Phase 2

**Phase 5: Workflow Integration**

9. Update cmd.implement.md Stage 6 to trigger phase generation
   - **What**: Modify the "Save Approved Tasks" stage to include a step that invokes the phase file and manifest generation workflow after writing implementation.md
   - **Why**: Ensures phase files and manifest are automatically created as part of the standard /implement workflow

10. Add confirmation message for successful generation
    - **What**: Insert prompt instruction to output confirmation message listing number of phase files and tasks in manifest after generation completes
    - **Why**: Provides user feedback that phase chunking succeeded

**Dependencies**: Phase 3, Phase 4

**Phase 6: Edge Case Handling**

11. Add single-phase detection logic to prompt
    - **What**: Include conditional logic in prompt that checks if implementation.md contains only one phase, and if so, names the file `phase_1.md` (not `phase.md`)
    - **Why**: Handles edge case from spec: "Implementation.md has only one phase (create single phase file, not phase_1.md)" - actually correcting to use phase_1.md for consistency

12. Add empty phase handling instructions
    - **What**: Add prompt logic to skip file creation for phases with zero tasks, but document in manifest with note
    - **Why**: Handles edge case: "Phase contains no tasks (skip file creation, document in manifest)"

13. Add special character escaping for JSON
    - **What**: Include explicit instructions for escaping quotes, backslashes, newlines in task descriptions when building JSON
    - **Why**: Handles edge case: "Task descriptions contain special characters that break JSON"

**Dependencies**: Phase 5

---

**Integration Points**

- **`/specimin:cmd.implement` command**: Modified to include phase generation workflow as final stage before completion. Existing stages 1-6 remain unchanged; new stage 7 added for phase chunking.

- **`.specimin/plans/{branch}/` directory structure**: Extended with new `tasks/` subdirectory containing generated phase files and manifest. Existing spec.md, plan.md, implementation.md files unchanged.

- **Coding agent workflow**: Future coding agents will query manifest.json for task status and read phase files for context. This integration point is prepared but not implemented in this feature (out of scope per spec).

---

**Testing Strategy**

**Unit Testing**:
- Phase file generation: Verify that implementation.md with N phases produces N correctly named phase_N.md files
- Task extraction: Verify all tasks from implementation.md appear in phase files with correct IDs and descriptions
- Manifest generation: Verify manifest.json is valid JSON with correct structure (array of objects with id, description, phase, status fields)
- Edge case: Single phase produces phase_1.md (not phase.md or unnamed file)
- Edge case: Empty phase skips file creation but documents in manifest

**Integration Testing**:
- Run `/specimin:cmd.implement` on a test feature with multi-phase implementation.md
- Verify tasks/ directory created with correct phase files and manifest
- Verify manifest.json contains all tasks with status "pending"
- Verify phase files contain correct subset of tasks

**End-to-End Scenarios**:
- Complete workflow: `/spec` → `/feature.plan` → `/implement` → verify tasks/ directory and manifest generated
- Regeneration: Run `/implement` twice, verify second run overwrites previous phase files and manifest cleanly
- Task status update: Manually edit manifest.json status field, verify JSON remains valid

**Edge Cases**:
- Implementation with 1 phase: Verify single phase_1.md created
- Implementation with 10+ phases: Verify all phase files created and numbered correctly
- Task descriptions with special chars: Verify JSON escaping works (quotes, newlines, unicode)
- Empty phase: Verify no file created, but phase documented in manifest metadata

---

**Risk Assessment & Mitigation**

**Risk**: LLM parsing fails to correctly identify phase boundaries in implementation.md
- **Mitigation 1**: Enforce strict phase header format in cmd.implement.md template (`## Phase N: {Name}`)
- **Mitigation 2**: Include validation step in prompt that counts phases and asks LLM to confirm count before generation
- **Mitigation 3**: Add error handling that detects parsing failures (e.g., 0 phases found) and displays actionable error message

**Risk**: JSON manifest corruption from improper escaping of special characters
- **Mitigation 1**: Use explicit JSON escaping instructions in prompt with examples
- **Mitigation 2**: Add validation step that parses JSON before writing to detect syntax errors
- **Mitigation 3**: Consider future enhancement to use Python json module for guaranteed valid output

**Risk**: Phase files and manifest get out of sync if implementation.md is regenerated
- **Mitigation 1**: Document in prompt that regenerating implementation.md should also regenerate phase files and manifest
- **Mitigation 2**: Add warning message if tasks/ directory already exists before generation
- **Mitigation 3**: Per spec edge case "Implementation.md is regenerated", determine overwrite strategy (current approach: overwrite fully)

**Risk**: Multiple agents attempt to update manifest.json simultaneously
- **Mitigation 1**: Document in implementation guide that manifest updates should be sequential, not parallel
- **Mitigation 2**: Use Edit tool's atomic string replacement to reduce corruption risk
- **Mitigation 3**: Future enhancement: Add file locking mechanism or optimistic concurrency control (out of scope for v1)

**Risk**: Agent crashes mid-phase, manifest status becomes stale
- **Mitigation 1**: Per spec: "manifest preserves completed task status for resume" - this is by design, no mitigation needed
- **Mitigation 2**: Document recovery procedure: check manifest.json for last completed task, resume from next pending
- **Mitigation 3**: Consider future enhancement: add timestamp field to detect stale in-progress tasks (out of scope)
